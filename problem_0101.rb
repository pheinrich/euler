require 'projectEuler'

# 
class Problem_0101
  def title; 'Optimum polynomial' end
  def solution;  end

  # If we are presented with the first k terms of a sequence it is impossible
  # to say with certainty the value of the next term, as there are infinitely
  # many polynomial functions that can model the sequence.
  #
  # As an example, let us consider the sequence of cube numbers. This is
  # defined by the generating function,
  # u_n = n^3: 1, 8, 27, 64, 125, 216, ...
  #
  # Suppose we were only given the first two terms of this sequence. Working
  # on the principle that "simple is best" we should assume a linear relation-
  # ship and predict the next term to be 15 (common difference 7). Even if we
  # were presented with the first three terms, by the same principle of
  # simplicity, a quadratic relationship should be assumed.
  #
  # We shall define OP(k, n) to be the nth term of the optimum polynomial gen-
  # erating function for the first k terms of a sequence. It should be clear
  # that OP(k, n) will accurately generate the terms of the sequence for
  # n ≤ k, and potentially the first incorrect term (FIT) will be OP(k, k+1);
  # in which case we shall call it a bad OP (BOP).
  #
  # As a basis, if we were only given the first term of sequence, it would be
  # most sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u_1.
  #
  # Hence we obtain the following OPs for the cubic sequence:
  #
  #     OP(1, n) = 1             1, [1], 1, 1, ...
  #     OP(2, n) = 7n−6          1, 8, [15], ...
  #     OP(3, n) = 6n^2−11n+6    1, 8, 27, [58], ...
  #     OP(4, n) = n^3           1, 8, 27, 64, 125, ...
  #
  # Clearly no BOPs exist for k ≥ 4.
  #
  # By considering the sum of FITs generated by the BOPs (indicated by []
  # above), we obtain 1 + 15 + 58 = 74.
  #
  # Consider the following tenth degree polynomial generating function:
  #
  #      u_n = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10
  #
  # Find the sum of FITs for the BOPs.

  def next_in_seq( points )
    (0...points.length).map do |i|
      coeffs = points.reject.each_with_index {|p, j| j == i}
      coeffs.each_with_index do |c, j|
        
      end
    end
  end
  
#  def solve( coeffs = [1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1] )
  def solve( coeffs = [0, 0, 0, 1] )
    # Compute the first n terms in the polynomial sequence defined by the co-
    # efficients specified. 
    u = (1..coeffs.length).map do |x|
      # The coefficients uniquely define the sequence. For example, the array
      # [0, 0, 0, 1] corresponds to f(x) = x^3, since f(x) = (0)(x^0) +
      # (0)(x^1) + (0)(x^2) + (1)(x^3).
      coeffs.each_with_index.inject( 0 ) {|acc, (a, i)| acc + (a * x**i)}
    end

    fits = (2..u.length).map do |n|
      next_in_seq( u[0, n] )
    end

#    puts fits.inspect
#    1 + fits.reduce( :+ )
  end
end
