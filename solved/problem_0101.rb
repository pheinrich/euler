require 'projectEuler'

class Problem_0101
  def title; 'Optimum polynomial' end
  def difficulty; 35 end

  # If we are presented with the first k terms of a sequence it is impossible
  # to say with certainty the value of the next term, as there are infinitely
  # many polynomial functions that can model the sequence.
  #
  # As an example, let us consider the sequence of cube numbers. This is
  # defined by the generating function,
  # u_n = n^3: 1, 8, 27, 64, 125, 216, ...
  #
  # Suppose we were only given the first two terms of this sequence. Working
  # on the principle that "simple is best" we should assume a linear relation-
  # ship and predict the next term to be 15 (common difference 7). Even if we
  # were presented with the first three terms, by the same principle of
  # simplicity, a quadratic relationship should be assumed.
  #
  # We shall define OP(k, n) to be the nth term of the optimum polynomial gen-
  # erating function for the first k terms of a sequence. It should be clear
  # that OP(k, n) will accurately generate the terms of the sequence for
  # n ≤ k, and potentially the first incorrect term (FIT) will be OP(k, k+1);
  # in which case we shall call it a bad OP (BOP).
  #
  # As a basis, if we were only given the first term of sequence, it would be
  # most sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u_1.
  #
  # Hence we obtain the following OPs for the cubic sequence:
  #
  #     OP(1, n) = 1             1, [1], 1, 1, ...
  #     OP(2, n) = 7n−6          1, 8, [15], ...
  #     OP(3, n) = 6n^2−11n+6    1, 8, 27, [58], ...
  #     OP(4, n) = n^3           1, 8, 27, 64, 125, ...
  #
  # Clearly no BOPs exist for k ≥ 4.
  #
  # By considering the sum of FITs generated by the BOPs (indicated by []
  # above), we obtain 1 + 15 + 58 = 74.
  #
  # Consider the following tenth degree polynomial generating function:
  #
  #      u_n = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10
  #
  # Find the sum of FITs for the BOPs.

  def solve( coeffs = [1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1] )
    # Compute the first n terms in the polynomial sequence defined by the co-
    # efficients specified. Treat them as points along the x axis so we can
    # use our Lagrange polynomial interpolator.
    f = coeffs.poly_gen_func
    u = (1..coeffs.length).map.with_index {|c, i| [i + 1, f.call( c )]}

    # Create and call the interpolator function for progressively longer
    # subsets of the points, collecting the FITs.
    fits = (1...u.length).map do |n|
      u[0, n].lagrange_interp_func.call( n + 1 )
    end

    fits.reduce( :+ ).to_i
  end

  def solution; 'MzcwNzYxMTQ1MjY=' end
  def best_time; 0.0002670 end
  def effort; 35 end
  
  def completed_on; '2015-01-07' end
  def ordinality; 6_047 end
  def population; 361_780 end
  
  def refs; [] end
end
